# -*- coding: utf-8 -*-
"""labreport2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ygVrS-CJ2TrLtDwsdgjMg5HQPumKX1h
"""

import streamlit as st
import random

# --- Page Setup ---
st.set_page_config(page_title="Genetic Algorithm Bit Pattern", layout="centered")
st.title("ðŸ§¬ Genetic Algorithm Bit Pattern Generator")

# --- Parameters ---
POP_SIZE = 300
GEN_LENGTH = 80
GENERATIONS = 50

# --- Fitness Function ---
def fitness(individual):
    ones = sum(individual)
    return 80 - abs(ones - 50)  # max value = 80 when ones = 50

# --- Create a random population ---
def create_population():
    return [[random.randint(0, 1) for _ in range(GEN_LENGTH)] for _ in range(POP_SIZE)]

# --- Selection: pick top individuals based on fitness ---
def selection(population):
    scored = [(ind, fitness(ind)) for ind in population]
    scored.sort(key=lambda x: x[1], reverse=True)
    return [ind for ind, fit in scored[:POP_SIZE // 2]]  # keep best 50%

# --- Crossover: combine two parents to create two children ---
def crossover(parent1, parent2):
    point = random.randint(1, GEN_LENGTH - 2)
    child1 = parent1[:point] + parent2[point:]
    child2 = parent2[:point] + parent1[point:]
    return child1, child2

# --- Mutation: flip a bit with small probability ---
def mutate(individual, mutation_rate=0.01):
    return [1 - bit if random.random() < mutation_rate else bit for bit in individual]

# --- Main Genetic Algorithm ---
def genetic_algorithm(progress_bar, status_text):
    population = create_population()
    best_per_generation = []

    for generation in range(GENERATIONS):
        selected = selection(population)
        next_gen = []

        # Reproduce to maintain population size
        while len(next_gen) < POP_SIZE:
            parent1, parent2 = random.sample(selected, 2)
            child1, child2 = crossover(parent1, parent2)
            next_gen.extend([mutate(child1), mutate(child2)])

        population = next_gen[:POP_SIZE]

        # Track best individual
        best_ind = max(population, key=fitness)
        best_fit = fitness(best_ind)
        best_per_generation.append(best_fit)

        progress_bar.progress((generation + 1) / GENERATIONS)
        status_text.text(f"Generation {generation+1}/{GENERATIONS} | Best fitness: {best_fit} | Ones: {sum(best_ind)}")

    # Final result
    best_individual = max(population, key=fitness)
    return best_individual, best_per_generation

# --- Streamlit UI ---
if st.button("ðŸš€ Run Genetic Algorithm"):
    st.write("### Running Genetic Algorithm...")
    progress_bar = st.progress(0)
    status_text = st.empty()

    best, best_fit_list = genetic_algorithm(progress_bar, status_text)

    st.success("âœ… Optimization Complete!")
    st.write(f"**Best Fitness:** {fitness(best)}")
    st.write(f"**Number of Ones:** {sum(best)}")
    st.write(f"**Bit Pattern:** {''.join(map(str, best))}")

    # Plot fitness over generations
    st.line_chart(best_fit_list, height=250)

!pip install streamlit